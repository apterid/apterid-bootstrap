// Copyright © 2015 The Apterid Developers

using System.Numerics;

ironmeta ApteridParser<char, Syntax.Node>
{
    ApteridSource = SourcePart*:src EOF -> { src };

    SourcePart = Directive | TopLevelModule | EndSpace+ | ErrorSection+;

    /////////////////////////////////////////////////////////////////
    // Directives

    Directive = '#' WS? DirectiveExpression EndSpace;

    DirectiveExpression = "if" SpaceOrComment '!'? SpaceOrComment Identifier;
    DirectiveExpression = "endif";

    /////////////////////////////////////////////////////////////////
    // Modules

    TopLevelModule = 
        WS?:indent 
        "module" SpaceOrComment QualifiedIdentifier SpaceOrComment? '=' EndSpace EOL
        ModuleBody(indent)
        (EndSpace | !"modules must be separated by an empty line");

    ModuleBody :outer = 
          EndSpace*
          (
            (WS:inner ModuleItem(inner) EndSpace) ?(inner.Length() > outer.Length())
            | !"parts of a module must be indented"
          )
          ModulePart(inner)*
        | !"a module cannot be empty";

    ModulePart :indent = EndSpace;
    ModulePart :indent = WS:ws ModuleItem(indent) EndSpace ?(ws.Length() == indent.Length());
    ModulePart :indent = WS:ws ModuleItem(indent) EndSpace !"parts of a module must indented and aligned";
    ModulePart :indent = Directive;
    ModulePart :indent = WS:ws ErrorSection 
        ?(ws.Length() == indent.Length()) -> { Make<Syntax.ErrorSection>(_IM_Result) };

    ModuleItem :indent = Binding(indent);

    /////////////////////////////////////////////////////////////////
    // Bindings

    Binding :indent = Identifier:name WS? '=' WS? Expression;

    /////////////////////////////////////////////////////////////////
    // Expressions

    Expression :indent = Literal;

    Literal = IntegerLiteral;

    IntegerLiteral = DecimalInteger;

    DecimalInteger = /[\+-]?[0-9]+(_?[0-9]+)*/ -> 
        {
            var str = new string(_IM_Result.Inputs.ToArray());
            var value = BigInteger.Parse(str.Replace("_", ""));
            return Make<Syntax.Literal<BigInteger>>(_IM_Result, n => n.Value = value);
        };

    /////////////////////////////////////////////////////////////////
    // Lexicon
    
    Identifier = /_|_[_0-9a-zA-Z]+|[a-zA-Z][_0-9a-zA-Z]*/ -> 
        { Make<Syntax.Identifier>(_IM_Result) };

    QualifiedIdentifier = (Identifier '.')+:q Identifier:i ->
        {
            return Make<Syntax.QualifiedIdentifier>(_IM_Result, n => 
                {
                    n.Identifier = Make<Syntax.Identifier>(i);
                    n.Qualifiers = q.ResultsOf<Syntax.Identifier>();
                });
        };

    /////////////////////////////////////////////////////////////////
    // Comments

    SpaceOrComment = (WS | InlineComment)+;
    EndSpace = (WS? (LineComment | (InlineComment | WS)* EOL));

    InlineComment = "/*" (EOL | ~"*/" .)* "*/" -> { Make<Syntax.InlineComment>(_IM_Result) };
    InlineComment = "/*" (EOL | ~(EOF | "*/") .)* EOF !"unterminated comment";

    LineComment = ("//" (~EOL .)*):ec (EOL | EOF):eol ->
        {
            new Syntax.Node[]
            {
                Make<Syntax.EndComment>(ec),
                Make<Syntax.EndOfLine>(eol),
            }
        };

    /////////////////////////////////////////////////////////////////
    // ErrorSection

    ErrorSection = (~DoubleReturn .)+ DoubleReturn -> { Make<Syntax.ErrorSection>(_IM_Result) };
    DoubleReturn = EOL WS? (EOL | EOF);

    /////////////////////////////////////////////////////////////////
    // Whitespace

    WS = [' ' '\t']+ -> { Make<Syntax.Whitespace>(_IM_Result) };

    /////////////////////////////////////////////////////////////////
    // End-of-Line and End-of-File

    EOL = '\r'? '\n' ->
        {
            _memo.Positions.Add(_IM_Result.NextIndex);
            return Make<Syntax.EndOfLine>(_IM_Result);
        };

    EOF = ~. ->
        {
            _memo.Positions.Add(_IM_Result.NextIndex);
            return Make<Syntax.EndOfFile>(_IM_Result);
        };
}
